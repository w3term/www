stages:
  - build-test
  - release
  - build-prod

# Image is built when push on develop branch
build test:
  stage: build-test
  image:
    name: gcr.io/kaniko-project/executor:debug
    entrypoint: [""]
  script:
    - mkdir -p /kaniko/.docker
    - echo "{\"auths\":{\"$CI_REGISTRY\":{\"username\":\"gitlab-ci-token\",\"password\":\"$CI_JOB_TOKEN\"}}}" > /kaniko/.docker/config.json
    - >
      /kaniko/executor 
      --build-arg=CI_COMMIT_SHA=$CI_COMMIT_SHA 
      --build-arg=CI_COMMIT_TAG=$CI_COMMIT_TAG 
      --build-arg=CI_COMMIT_MESSAGE="$CI_COMMIT_MESSAGE"
      --build-arg=APP_VERSION="$CI_COMMIT_SHORT_SHA"
      --context $CI_PROJECT_DIR 
      --dockerfile $CI_PROJECT_DIR/Dockerfile 
      -d $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
  only:
    - develop

# New release tag only created when commit done on main branch
release:
  image: node:20
  stage: release
  script:
    - touch CHANGELOG.md
    - npm install @semantic-release/gitlab @semantic-release/exec @semantic-release/changelog
    - npx semantic-release
  artifacts:
    paths:
      - CHANGELOG.md
  only:
    - main

# Image is built on each new tag
build production:
  stage: build-prod
  image:
    name: gcr.io/kaniko-project/executor:debug
    entrypoint: [""]
  script:
    - mkdir -p /kaniko/.docker
    - echo "{\"auths\":{\"$CI_REGISTRY\":{\"username\":\"gitlab-ci-token\",\"password\":\"$CI_JOB_TOKEN\"}}}" > /kaniko/.docker/config.json
    - >
      /kaniko/executor 
      --build-arg=CI_COMMIT_SHA=$CI_COMMIT_SHA 
      --build-arg=CI_COMMIT_TAG=$CI_COMMIT_TAG 
      --build-arg=CI_COMMIT_MESSAGE="$CI_COMMIT_MESSAGE"
      --build-arg=APP_VERSION="$CI_COMMIT_TAG"
      --context $CI_PROJECT_DIR 
      --dockerfile $CI_PROJECT_DIR/Dockerfile 
      -d $CI_REGISTRY_IMAGE:$CI_COMMIT_TAG 
      -d $CI_REGISTRY_IMAGE:latest
  only:
    - tags